
\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}

% Define colors for code listings
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Set code listing style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\begin{document}

\begin{center}
    \Large{\textbf{PHY-407: Simulation Methods in Statistical Physics}}\\
    \large{IDD Part-IV (Session: 2024-25)}\\
    \large{End-semester Examination}\\
    \vspace{0.5cm}
    \large{Sameer Wanjari - 21174028}
\end{center}

\section*{Question 1 \hfill [7 + (8) = 15]}
Imagine an ant walking on a two-dimensional square grid, but it makes a trail such that it cannot go back to any square it has already stepped on. Consider total time steps of $(T = 10000)$.

\subsection*{a. Algorithm Implementation}
Below is the algorithm for implementing the self-avoiding random walk:

\begin{lstlisting}[language=Python, caption=Self-avoiding random walk algorithm]
import numpy as np
import matplotlib.pyplot as plt
from collections import defaultdict
import time

def self_avoiding_walk(T=10000):
    """
    Simulates a self-avoiding random walk on a 2D square grid.
    
    Args:
        T (int): Total number of time steps
    
    Returns:
        tuple: (positions, success) where positions is a list of (x,y) coordinates 
        and success is a boolean indicating if the walk completed T steps
    """
    # Directions: right, up, left, down
    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    
    # Initialize the current position and visited positions
    current_pos = (0, 0)
    positions = [current_pos]
    visited = {current_pos}
    
    # Perform the walk
    for _ in range(T):
        # Find valid neighbors (not visited)
        valid_moves = []
        for dx, dy in directions:
            next_pos = (current_pos[0] + dx, current_pos[1] + dy)
            if next_pos not in visited:
                valid_moves.append(next_pos)
        
        # If no valid moves are available, the walk is trapped
        if not valid_moves:
            return positions, False
        
        # Choose a random valid move
        next_pos = valid_moves[np.random.randint(0, len(valid_moves))]
        
        # Update position and record it
        current_pos = next_pos
        positions.append(current_pos)
        visited.add(current_pos)
    
    return positions, True

def draw_trajectories(num_realisations=5, T=10000):
    """
    Draws trajectories for multiple realizations of the self-avoiding walk.
    
    Args:
        num_realisations (int): Number of independent realizations
        T (int): Total number of time steps
    
    Returns:
        list: List of trajectories (positions) for each realization
    """
    all_trajectories = []
    fig, ax = plt.subplots(figsize=(10, 8))
    
    for i in range(num_realisations):
        positions, success = self_avoiding_walk(T)
        all_trajectories.append(positions)
        
        # Extract x and y coordinates for plotting
        x_coords, y_coords = zip(*positions)
        
        # Plot trajectory
        ax.plot(x_coords, y_coords, '-', label=f'Walk {i+1} (Steps: {len(positions)-1})')
        
        # Mark start and end points
        ax.plot(x_coords[0], y_coords[0], 'go', markersize=8, label='Start' if i == 0 else "")
        ax.plot(x_coords[-1], y_coords[-1], 'ro', markersize=8, label='End' if i == 0 else "")
    
    ax.set_title(f'Self-Avoiding Random Walk Trajectories (T={T})')
    ax.set_xlabel('X Position')
    ax.set_ylabel('Y Position')
    ax.legend()
    ax.grid(True)
    plt.tight_layout()
    plt.savefig('trajectory_plot.png', dpi=300)
    plt.close()
    
    return all_trajectories

def calculate_msd(num_realisations=100, T=10000):
    """
    Calculates the mean square displacement (MSD) as a function of time.
    
    Args:
        num_realisations (int): Number of independent realizations
        T (int): Total number of time steps
    
    Returns:
        tuple: (time_points, msd_values)
    """
    # Store total square displacement for each time step
    total_squared_displacement = defaultdict(float)
    count_per_time = defaultdict(int)
    
    print(f"Calculating MSD with {num_realisations} realizations...")
    start_time = time.time()
    
    for i in range(num_realisations):
        if i % 10 == 0 and i > 0:
            elapsed = time.time() - start_time
            print(f"Completed {i}/{num_realisations} walks ({elapsed:.2f} seconds)")
        
        positions, success = self_avoiding_walk(T)
        
        # Calculate squared displacement for each time step
        origin = positions[0]
        for t, pos in enumerate(positions):
            dx = pos[0] - origin[0]
            dy = pos[1] - origin[1]
            total_squared_displacement[t] += dx**2 + dy**2
            count_per_time[t] += 1
    
    # Calculate MSD for each time step
    time_points = sorted(count_per_time.keys())
    msd_values = [total_squared_displacement[t] / count_per_time[t] for t in time_points]
    
    # Plot MSD
    plt.figure(figsize=(10, 6))
    plt.plot(time_points, msd_values, 'b.-')
    plt.xlabel('Time Steps')
    plt.ylabel('Mean Square Displacement')
    plt.title('Mean Square Displacement vs Time')
    plt.grid(True)
    plt.xscale('log')
    plt.yscale('log')
    plt.savefig('msd_plot.png', dpi=300)
    
    # Fit MSD with t^α
    log_time = np.log(time_points[1:])  # Skip t=0
    log_msd = np.log(msd_values[1:])    # Skip t=0
    
    # Linear regression on log-log data
    coef = np.polyfit(log_time, log_msd, 1)
    alpha = coef[0]
    
    # Plot fit
    plt.figure(figsize=(10, 6))
    plt.plot(time_points[1:], msd_values[1:], 'b.', label='Data')
    plt.plot(time_points[1:], np.exp(coef[1]) * np.power(time_points[1:], alpha), 'r-', 
             label=f'Fit: MSD ∝ t^{alpha:.4f}')
    plt.xlabel('Time Steps')
    plt.ylabel('Mean Square Displacement')
    plt.title(f'MSD vs Time with Power Law Fit (α = {alpha:.4f})')
    plt.grid(True)
    plt.xscale('log')
    plt.yscale('log')
    plt.legend()
    plt.savefig('msd_fit_plot.png', dpi=300)
    
    print(f"Alpha value: {alpha:.4f}")
    print(f"For normal random walk, α would be 1.0")
    
    return time_points, msd_values, alpha

def calculate_pdf(num_realisations=1000, time_points=[5, 50, 100, 1000, 5000, 10000]):
    """
    Calculates the probability distribution function (PDF) of positions at specified time points.
    
    Args:
        num_realisations (int): Number of independent realizations
        time_points (list): Time points at which to calculate the PDF
    
    Returns:
        dict: Dictionary mapping time points to position PDFs
    """
    position_data = {t: [] for t in time_points}
    max_time = max(time_points)
    
    print(f"Calculating PDF with {num_realisations} realizations...")
    start_time = time.time()
    
    for i in range(num_realisations):
        if i % 100 == 0 and i > 0:
            elapsed = time.time() - start_time
            print(f"Completed {i}/{num_realisations} walks ({elapsed:.2f} seconds)")
            
        positions, success = self_avoiding_walk(max_time)
        
        if not success:
            # If the walk didn't complete, use the data we have
            for t in time_points:
                if t < len(positions):
                    position_data[t].append(positions[t])
        else:
            # If the walk completed successfully, use all data points
            for t in time_points:
                if t < len(positions):
                    position_data[t].append(positions[t])
    
    # Create PDFs and plot
    for t in time_points:
        if not position_data[t]:
            print(f"No data available for t={t}")
            continue
            
        positions = np.array(position_data[t])
        x_coords = positions[:, 0]
        y_coords = positions[:, 1]
        
        # Create 2D histogram as a proper heatmap
        plt.figure(figsize=(10, 8))
        
        # Calculate the range for the grid
        max_range = max(abs(x_coords.max()), abs(x_coords.min()), 
                        abs(y_coords.max()), abs(y_coords.min())) + 5
        bin_size = max(1, int(max_range / 25))  # Adjust bin size based on range
        
        # Create 2D histogram
        hist, xedges, yedges = np.histogram2d(
            x_coords, y_coords, 
            bins=[np.arange(-max_range, max_range+bin_size, bin_size),
                  np.arange(-max_range, max_range+bin_size, bin_size)],
            density=True
        )
        
        # Create heatmap
        extent = [xedges[0], xedges[-1], yedges[0], yedges[-1]]
        plt.imshow(hist.T, origin='lower', aspect='equal', extent=extent, cmap='hot')
        cbar = plt.colorbar(label='Probability Density')
        plt.xlabel('X Position')
        plt.ylabel('Y Position')
        plt.title(f'Position PDF Heatmap at t={t}')
        plt.grid(False)
        plt.tight_layout()
        plt.savefig(f'pdf_heatmap_t{t}.png', dpi=300)
        plt.close()
        
        # Calculate radial distribution
        r = np.sqrt(x_coords**2 + y_coords**2)
        plt.figure(figsize=(8, 6))
        plt.hist(r, bins=30, density=True, alpha=0.7)
        plt.xlabel('Distance from Origin')
        plt.ylabel('Probability Density')
        plt.title(f'Radial PDF at t={t}')
        plt.grid(True)
        plt.savefig(f'radial_pdf_t{t}.png', dpi=300)
        plt.close()
    
    return position_data

def main():
    np.random.seed(42)  # For reproducibility
    
    # Part b: Draw trajectories
    print("Part b: Drawing trajectories...")
    trajectories = draw_trajectories(num_realisations=5)
    
    # Part c: Calculate MSD
    print("\nPart c: Calculating MSD...")
    time_points, msd_values, alpha = calculate_msd(num_realisations=100)
    
    # Part d: Calculate PDF
    print("\nPart d: Calculating PDF...")
    pdfs = calculate_pdf(num_realisations=1000)
    
    # Part e: Compare alpha with normal random walk
    print("\nPart e: Comparing with normal random walk...")
    print(f"Calculated alpha value: {alpha:.4f}")
    print(f"Normal random walk alpha: 1.0")
    print(f"Difference: {abs(alpha - 1.0):.4f}")
    
    if alpha < 1.0:
        print("The walk is sub-diffusive compared to normal random walk.")
    elif alpha > 1.0:
        print("The walk is super-diffusive compared to normal random walk.")
    else:
        print("The walk exhibits normal diffusion.")

if __name__ == "__main__":
    main()
\end{lstlisting}

\subsection*{b. Ant Trajectory for Five Independent Realizations}
Figure \ref{fig:trajectories} shows the trajectories of the ant for five independent realizations.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{trajectory_plot.png}
    \caption{Trajectories of the ant for five independent realizations.}
    \label{fig:trajectories}
\end{figure}

\subsection*{c. Mean Square Displacement (MSD)}
Figure shows the mean square displacement of the ant as a function of time.



\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{msd_plot.png}
    \caption{Mean square displacement as a function of time.}
    \label{fig:msd}
\end{figure}

\subsection*{d. Probability Distribution Function (PDF)}
Figure shows the probability distribution function of the position at different time steps $(T = 5, 50, 100, 1000, 5000, 10000)$.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{pdf_heatmap_t5.png}
    \caption{Heatmap with .}
    \label{fig:msd}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{pdf_heatmap_t50.png}
    \caption{.}
    \label{fig:msd}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{pdf_heatmap_t100.png}
    \caption{.}
    \label{fig:msd}
\end{figure}





\subsection*{e. Calculation of $\alpha$ from MSD Fit}
The MSD was fitted with $t^\alpha$, and the value of $\alpha$ was calculated and compared with normal random walk.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{msd_fit_plot.png}
    \caption{Mean square displacement as a function of time.}
    \label{fig:msd}
\end{figure}



The calculated value of $\alpha$ is 1.41 compared to $\alpha = 1$ for normal random walk.

\subsection*{Conclusion}
The self-avoiding random walk simulation on a 2D square grid successfully modeled the movement of an ant constrained from revisiting previously stepped squares over 10,000 time steps. The implemented algorithm effectively generated trajectories for multiple realizations, as visualized in Figure 1, demonstrating the variability in paths due to the stochastic nature of the walk. The mean square displacement (MSD) analysis, shown in Figures 2--6, revealed a power-law relationship MSD $\sim t^\alpha$, with a calculated exponent $\alpha = 1.41$. This value indicates super-diffusive behavior compared to a normal random walk ($\alpha = 1.0$), suggesting that the self-avoiding constraint leads to more extended exploration of the grid. The difference of 0.41 in $\alpha$ highlights the impact of the self-avoiding condition, which prevents backtracking and promotes longer-range movements. The probability distribution function (PDF) of positions at various time steps (5, 50, 100, 1000, 5000, 10000), illustrated in the provided figure, showed evolving spatial distributions, with heatmaps indicating higher probability densities in regions explored at later times.
The radial PDF further confirmed the spread of positions, consistent with super-diffusive dynamics. However, due to the restrictive nature of the self-avoiding condition, the particle was often unable to continue walking up to higher time steps such as 1000, 5000, or 10000 in several realizations, as it would become trapped with no available unvisited neighboring sites. This limitation affected the generation of reliable PDF data at these later time steps. These results collectively underscore the effectiveness of the simulation in capturing the unique diffusive properties of self-avoiding walks.


\section*{Question 3 \hfill [7 + (8) = 15]}
Consider the Ising Hamiltonian:
\begin{equation}
H = -J\sum_{(i,j)}s_is_j - h_z\sum_i s_i
\end{equation}

where $J > 0$ denotes the ferromagnetic exchange interaction between nearest-neighbor sites. For computational purposes, set the scaled parameters $J = 1$ and $k_B = 1$. The spin variable $s_i$ takes values of either +1 (up) or -1 (down), and $h_z$ represents the external magnetic field along the positive z-direction. The notation $(i, j)$ indicates summation over nearest-neighbor pairs.

\subsection*{Implementation of Monte Carlo Simulation for Ising Model}
Below is the implementation of the Metropolis algorithm within a single-spin-flip Monte Carlo approach for the 2D Ising model:

\begin{lstlisting}[language=c++, caption=Monte Carlo simulation for 2D Ising model]

#include <iostream>
#include <vector>
#include <random>
#include <cmath>
#include <fstream>
#include <string>
#include <iomanip>
using namespace std;

class IsingModel {
private:
    int L; // Lattice size (L x L)
    vector<vector<int>> lattice; // 2D lattice of spins
    double J; 
    double kB; 
    double h_z; 
    mt19937 rng; // Random number generator
    uniform_real_distribution<double> dist; 
    uniform_int_distribution<int> pos_dist; 
    unsigned long seed; // Random seed for reproducibility

public:
    // Constructor
    IsingModel(int size, double exchange, double boltzmann, double field, unsigned long custom_seed) 
        : L(size), J(exchange), kB(boltzmann), h_z(field), 
          lattice(size, vector<int>(size, 1)), // Initializing all spins up
          dist(0.0, 1.0), pos_dist(0, size-1), seed(custom_seed) {
        
        rng.seed(seed);
    }

    // Calculating energy change for a spin flip at position (i,j)
    double calculateDeltaE(int i, int j) {
        int spin = lattice[i][j];
        int sum_neighbors = 0;
        
        sum_neighbors += lattice[(i+1) % L][j];       // R
        sum_neighbors += lattice[(i-1+L) % L][j];     // L
        sum_neighbors += lattice[i][(j+1) % L];       // U
        sum_neighbors += lattice[i][(j-1+L) % L];     // D
        
        // Delta E = 2*J*s_i*sum_neighbors + 2*h_z*s_i
        return 2.0 * J * spin * sum_neighbors + 2.0 * h_z * spin;
    }

    // Calculating total energy of the system
    double calculateEnergy() {
        double energy = 0.0;
        
        // Sum over all lattice sites
        for (int i = 0; i < L; ++i) {
            for (int j = 0; j < L; ++j) {
                if (j < L-1) energy -= J * lattice[i][j] * lattice[i][j+1];
                if (i < L-1) energy -= J * lattice[i][j] * lattice[i+1][j];
                
                energy -= h_z * lattice[i][j];
            }
        }
        
        return energy;
    }

    // Calculating magnetization per spin
    double calculateMagnetization() {
        double M = 0.0;
        
        for (int i = 0; i < L; ++i) {
            for (int j = 0; j < L; ++j) {
                M += lattice[i][j];
            }
        }
        
        return M / (L * L);
    }

    // Performing a single Monte Carlo step (sweep)
    void mcStep(double T) {
        for (int step = 0; step < L * L; ++step) {
            // Randomly selecting a site
            int i = pos_dist(rng);
            int j = pos_dist(rng);
            
            double deltaE = calculateDeltaE(i, j);
            
            // Metropolis acceptance criterion
            if (deltaE <= 0.0 || dist(rng) < exp(-deltaE / (kB * T))) {
                lattice[i][j] *= -1; // Flipping the spin
            }
        }
    }

    pair<double, double> simulateAtTemperature(double T, int equilibration_steps, int production_steps) {
        // Equilibration phase
        for (int step = 0; step < equilibration_steps; ++step) {
            mcStep(T);
        }
        
        // Production phase
        double M_avg = 0.0;
        double M2_avg = 0.0;
        
        for (int step = 0; step < production_steps; ++step) {
            mcStep(T);
            double M = calculateMagnetization();
            double abs_M = abs(M);
            
            M_avg += abs_M;
            M2_avg += M * M;
        }
        
        M_avg /= production_steps;
        M2_avg /= production_steps;
        
        // Calculate susceptibility: χ = (⟨M²⟩ - ⟨|M|⟩²) / (k_B * T)
        double susceptibility = (M2_avg - M_avg * M_avg) * L * L / (kB * T);
        
        return {M_avg, susceptibility};
    }
};

void runEnsembles(int L, double J, double kB, double h_z, 
                 double T_start, double T_end, double T_step,
                 int n_ensembles, int equilibration_steps, int production_steps,
                 const string& filename) {
    
    // Prepare output file
    ofstream output(filename);
    output << "Temperature,AbsoluteMagnetization,MagnetizationError,Susceptibility,SusceptibilityError\n";
    
    // Loop over temperatures
    for (double T = T_start; T <= T_end + T_step; T += T_step) {
        cout << "Simulating T = " << T << endl;
        
        vector<double> magnetizations(n_ensembles);
        vector<double> susceptibilities(n_ensembles);
        
        for (int e = 0; e < n_ensembles; ++e) {
            cout << "  Ensemble " << (e+1) << "/" << n_ensembles << endl;
            
            unsigned long seed = 12345 + e;
            IsingModel model(L, J, kB, h_z, seed);
            
            auto [M_avg, susceptibility] = model.simulateAtTemperature(T, equilibration_steps, production_steps);
            
            magnetizations[e] = M_avg;
            susceptibilities[e] = susceptibility;
        }
        
        double M_ensemble_avg = 0.0;
        double chi_ensemble_avg = 0.0;
        
        for (int e = 0; e < n_ensembles; ++e) {
            M_ensemble_avg += magnetizations[e];
            chi_ensemble_avg += susceptibilities[e];
        }
        
        M_ensemble_avg /= n_ensembles;
        chi_ensemble_avg /= n_ensembles;
        
        double M_error = 0.0;
        double chi_error = 0.0;
        
        for (int e = 0; e < n_ensembles; ++e) {
            M_error += (magnetizations[e] - M_ensemble_avg) * (magnetizations[e] - M_ensemble_avg);
            chi_error += (susceptibilities[e] - chi_ensemble_avg) * (susceptibilities[e] - chi_ensemble_avg);
        }
        
        M_error = sqrt(M_error / (n_ensembles * (n_ensembles - 1)));
        chi_error = sqrt(chi_error / (n_ensembles * (n_ensembles - 1)));
        
        output << fixed << setprecision(6)
               << T << "," 
               << M_ensemble_avg << "," 
               << M_error << "," 
               << chi_ensemble_avg << "," 
               << chi_error << endl;
    }
    
    output.close();
}

int main(int argc, char* argv[]) {
    double h_z = 0.0;
    if (argc > 1) h_z = stod(argv[1]);
    
    int L = 40;  
    if (argc > 2) L = stoi(argv[2]);
    
    // Parameters
    double J = 1.0;           
    double kB = 1.0;          
    double T_start = 0.1;     
    double T_end = 3.0;       
    double T_step = 0.1;      
    int n_ensembles = 5;      // Number of independent ensembles
    int equilibration_steps = 1000;  // Equilibration steps per temperature
    int production_steps = 5000;    // Production steps per temperature
    
    string filename = "ising_L" + to_string(L) + "_h" + to_string(h_z) + "_ensemble.csv";
    
    runEnsembles(L, J, kB, h_z, T_start, T_end, T_step, 
                n_ensembles, equilibration_steps, production_steps, filename);
    
    cout << "Simulation completed. Results saved to " << filename << endl;
    
    return 0;
}
\end{lstlisting}



\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{ising_model_results.png}
    \caption{Graphs for the 2D Ising model.}
    \label{fig:ising_results}
\end{figure}

\subsection*{Conclusion:}
The Monte Carlo simulation of the 2D Ising model, implemented using the Metropolis algorithm with single-spin-flip dynamics, provided insights into the magnetic properties of a ferromagnetic system. The simulation was conducted on a 40$\times$40 lattice with scaled parameters $J=1$ and $k_B=1$, and an external magnetic field $h_z$ adjustable via input. The results, as depicted in Figure 7, included the absolute magnetization and susceptibility as functions of temperature, computed over multiple ensembles to ensure statistical reliability. The simulation captured the phase transition behavior characteristic of the Ising model, with magnetization decreasing and susceptibility peaking near the critical temperature. The ensemble averaging and error calculations enhanced the robustness of the results, as saved in the output CSV file. The implementation efficiently handled periodic boundary conditions and random spin flips, enabling accurate computation of thermodynamic quantities. These findings validate the Monte Carlo approach for studying phase transitions in the Ising model and demonstrate its ability to reproduce expected physical behavior, such as the transition from ordered to disordered states with increasing temperature.

\section*{Question 5 \hfill [7 + (8) = 15]}
Consider a two-dimensional box of size $L = 50$ (you may use a bigger system size of your choice). Randomly place $N = \rho \times L^2$ Lennard-Jones (LJ) particles (e.g., Argon gas) in the box, avoiding particle overlap. Here, $\rho = 0.7$ denotes the particle number density. Initialize each velocity component by drawing from either (i) a Gaussian distribution with zero mean and unit variance or (ii) a uniform distribution: $v_i \in (-0.5, 0.5)$. Use a truncated and shifted LJ pair potential, along with the velocity-Verlet integration algorithm, with a time step $\Delta t = 0.001$ (you may use a higher choice). Simulate the system for a total time $t = 100$, where $t$ is defined as the number of simulation steps multiplied by $\Delta t$. Employ the Verlet neighbor list to enhance computational efficiency.

\subsection*{a. Algorithm Implementation}
Below is the algorithm for implementing the Lennard-Jones MD simulation:

\begin{lstlisting}[language=C++, caption=Lennard-Jones MD simulation algorithm]
# Import necessary libraries
#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include <random>
#include <algorithm>

// Structure to represent a 2D point/vector
struct Vec2 {
    double x, y;
    
    Vec2() : x(0.0), y(0.0) {}
    Vec2(double x_, double y_) : x(x_), y(y_) {}
    
    // Vector addition
    Vec2 operator+(const Vec2& other) const {
        return Vec2(x + other.x, y + other.y);
    }
    
    // Vector subtraction
    Vec2 operator-(const Vec2& other) const {
        return Vec2(x - other.x, y - other.y);
    }
    
    // Scalar multiplication
    Vec2 operator*(double scalar) const {
        return Vec2(x * scalar, y * scalar);
    }
    
    // Magnitude squared
    double mag_squared() const {
        return x*x + y*y;
    }
    
    // Magnitude
    double mag() const {
        return std::sqrt(mag_squared());
    }
};

class MDSimulation {
private:
    // System parameters
    double L;              // Box size
    double rho;            // Number density
    int N;                 // Number of particles
    double dt;             // Time step
    int total_steps;       // Total simulation steps
    double r_cut;          // Cutoff radius for LJ potential
    double r_cut_sq;       // Square of cutoff radius
    bool use_gaussian;     // Flag for velocity initialization type
    
    // Particle data
    std::vector<Vec2> positions;
    std::vector<Vec2> velocities;
    std::vector<Vec2> forces;
    std::vector<Vec2> prev_forces; // For Velocity-Verlet integration
    
    // Energy and temperature data
    std::vector<double> potential_energy_data;
    std::vector<double> kinetic_energy_data;
    std::vector<double> total_energy_data;
    std::vector<double> temperature_data;
    std::vector<double> time_data;
    
    // For MSD calculation
    std::vector<Vec2> initial_positions;
    std::vector<double> msd_data;
    
    // Neighbor list
    struct NeighborList {
        std::vector<std::vector<int>> neighbors;
        std::vector<Vec2> ref_positions;
        double skin;
        double list_range_sq;
        bool needs_update;
        
        NeighborList(int n, double r_cut, double skin_factor = 0.3) : 
            neighbors(n), ref_positions(n), skin(r_cut * skin_factor), 
            list_range_sq(std::pow(r_cut + skin, 2)), needs_update(true) {}
    } neighbor_list;
    
    // Random number generator
    std::mt19937 rng;
    
public:
    MDSimulation(double L_, double rho_, double dt_, int total_steps_, bool use_gaussian_) :
        L(L_), rho(rho_), dt(dt_), total_steps(total_steps_), use_gaussian(use_gaussian_),
        r_cut(2.5), r_cut_sq(r_cut * r_cut), 
        neighbor_list(0, r_cut) {
        
        // Calculate number of particles based on density
        N = static_cast<int>(rho_ * L_ * L_);
        
        // Initialize vectors
        positions.resize(N);
        velocities.resize(N);
        forces.resize(N);
        prev_forces.resize(N);
        
        // Data vectors
        potential_energy_data.reserve(total_steps);
        kinetic_energy_data.reserve(total_steps);
        total_energy_data.reserve(total_steps);
        temperature_data.reserve(total_steps);
        time_data.reserve(total_steps);
        msd_data.reserve(total_steps);
        
        // Initialize neighbor list
        neighbor_list = NeighborList(N, r_cut);
        
        // Initialize random number generator
        std::random_device rd;
        rng = std::mt19937(rd());
        
        std::cout << "Initializing simulation with N = " << N << " particles" << std::endl;
    }
    
    // Place particles on a grid to avoid overlap
    void initialize_positions() {
        int side = static_cast<int>(std::ceil(std::sqrt(N)));
        double spacing = L / side;
        
        for (int i = 0; i < N; ++i) {
            int ix = i % side;
            int iy = i / side;
            
            // Add small random displacement to break symmetry
            std::uniform_real_distribution<double> small_disp(-0.1 * spacing, 0.1 * spacing);
            
            positions[i].x = (ix + 0.5) * spacing + small_disp(rng);
            positions[i].y = (iy + 0.5) * spacing + small_disp(rng);
            
            // Make sure particles stay within the box
            positions[i].x = std::fmod(positions[i].x + L, L);
            positions[i].y = std::fmod(positions[i].y + L, L);
        }
        
        // Store initial positions for MSD calculation
        initial_positions = positions;
    }
    
    void initialize_velocities() {
        double sum_vx = 0.0, sum_vy = 0.0;
        
        if (use_gaussian) {
            // Gaussian distribution with zero mean and unit variance
            std::normal_distribution<double> dist(0.0, 1.0);
            
            for (int i = 0; i < N; ++i) {
                velocities[i].x = dist(rng);
                velocities[i].y = dist(rng);
                sum_vx += velocities[i].x;
                sum_vy += velocities[i].y;
            }
        } else {
            // Uniform distribution in [-0.5, 0.5]
            std::uniform_real_distribution<double> dist(-0.5, 0.5);
            
            for (int i = 0; i < N; ++i) {
                velocities[i].x = dist(rng);
                velocities[i].y = dist(rng);
                sum_vx += velocities[i].x;
                sum_vy += velocities[i].y;
            }
        }
        
        // Remove center of mass motion
        double vx_cm = sum_vx / N;
        double vy_cm = sum_vy / N;
        
        for (int i = 0; i < N; ++i) {
            velocities[i].x -= vx_cm;
            velocities[i].y -= vy_cm;
        }
        
        // Scale velocities to set initial temperature
        double target_temp = 1.0;
        double current_temp = calculate_temperature();
        double scale_factor = std::sqrt(target_temp / current_temp);
        
        for (int i = 0; i < N; ++i) {
            velocities[i].x *= scale_factor;
            velocities[i].y *= scale_factor;
        }
    }
    
    // Calculate minimum image distance between two positions
    Vec2 minimum_image_vector(const Vec2& pos1, const Vec2& pos2) const {
        Vec2 dr = pos1 - pos2;
        
        // Apply periodic boundary conditions
        if (dr.x > 0.5 * L) dr.x -= L;
        else if (dr.x < -0.5 * L) dr.x += L;
        
        if (dr.y > 0.5 * L) dr.y -= L;
        else if (dr.y < -0.5 * L) dr.y += L;
        
        return dr;
    }
    
    // Update the neighbor list if necessary
    void update_neighbor_list() {
        bool needs_update = neighbor_list.needs_update;
        
        if (!needs_update && neighbor_list.ref_positions.size() == N) {
            // Check if any particle has moved more than half the skin distance
            double displacement_threshold = 0.25 * neighbor_list.skin * neighbor_list.skin;
            
            for (int i = 0; i < N; ++i) {
                Vec2 disp = minimum_image_vector(positions[i], neighbor_list.ref_positions[i]);
                if (disp.mag_squared() > displacement_threshold) {
                    needs_update = true;
                    break;
                }
            }
        } else {
            needs_update = true;
        }
        
        if (needs_update) {
            // Store reference positions
            neighbor_list.ref_positions = positions;
            
            // Reset neighbor lists
            for (int i = 0; i < N; ++i) {
                neighbor_list.neighbors[i].clear();
            }
            
            // Build neighbor lists
            for (int i = 0; i < N - 1; ++i) {
                for (int j = i + 1; j < N; ++j) {
                    Vec2 rij = minimum_image_vector(positions[i], positions[j]);
                    double r_sq = rij.mag_squared();
                    
                    if (r_sq < neighbor_list.list_range_sq) {
                        neighbor_list.neighbors[i].push_back(j);
                        neighbor_list.neighbors[j].push_back(i);
                    }
                }
            }
            
            neighbor_list.needs_update = false;
            std::cout << "Updated neighbor list" << std::endl;
        }
    }
    
    // Calculate forces and potential energy using LJ potential
    double calculate_forces() {
        // Reset forces
        for (int i = 0; i < N; ++i) {
            forces[i] = Vec2(0.0, 0.0);
        }
        
        double potential = 0.0;
        
        // Use neighbor list for efficiency
        update_neighbor_list();
        
        for (int i = 0; i < N; ++i) {
            for (const int j : neighbor_list.neighbors[i]) {
                if (j > i) {  // Avoid double counting
                    Vec2 rij = minimum_image_vector(positions[i], positions[j]);
                    double r_sq = rij.mag_squared();
                    
                    if (r_sq < r_cut_sq) {
                        double r_2 = 1.0 / r_sq;
                        double r_6 = r_2 * r_2 * r_2;
                        double r_12 = r_6 * r_6;
                        
                        // Lennard-Jones force: F = 24ε*[(2/r^13) - (1/r^7)]*r
                        double force_mag = 24.0 * (2.0 * r_12 - r_6) * r_2;
                        Vec2 force_ij = rij * force_mag;
                        
                        forces[i] = forces[i] + force_ij;
                        forces[j] = forces[j] - force_ij;  // Newton's third law
                        
                        // Lennard-Jones potential: V = 4ε*[(σ/r)^12 - (σ/r)^6]
                        // with ε = 1, σ = 1
                        potential += 4.0 * (r_12 - r_6);
                    }
                }
            }
        }
        
        return potential;
    }
    
    // Calculate kinetic energy and temperature
    double calculate_kinetic_energy() const {
        double kinetic = 0.0;
        
        for (int i = 0; i < N; ++i) {
            double v_sq = velocities[i].mag_squared();
            kinetic += 0.5 * v_sq;
        }
        
        return kinetic;
    }
    
    double calculate_temperature() const {
        // T = (2 * K) / (N * d * k_B)
        // Where d = 2 (dimension), k_B = 1 (in reduced units)
        return calculate_kinetic_energy() / N;
    }
    
    // Calculate mean squared displacement
    double calculate_msd() const {
        double sum_sq_disp = 0.0;
        
        for (int i = 0; i < N; ++i) {
            Vec2 disp = minimum_image_vector(positions[i], initial_positions[i]);
            sum_sq_disp += disp.mag_squared();
        }
        
        return sum_sq_disp / N;
    }
    
    // Velocity-Verlet integration step
    void velocity_verlet_step() {
        // Store current forces for second half of velocity update
        prev_forces = forces;
        
        // Update positions: r(t+dt) = r(t) + v(t)*dt + 0.5*f(t)*dt^2
        for (int i = 0; i < N; ++i) {
            positions[i] = positions[i] + velocities[i] * dt + prev_forces[i] * (0.5 * dt * dt);
            
            // Apply periodic boundary conditions
            positions[i].x = std::fmod(positions[i].x + L, L);
            positions[i].y = std::fmod(positions[i].y + L, L);
        }
        
        // Calculate new forces f(t+dt)
        double potential = calculate_forces();
        
        // Update velocities: v(t+dt) = v(t) + 0.5*[f(t) + f(t+dt)]*dt
        for (int i = 0; i < N; ++i) {
            velocities[i] = velocities[i] + (prev_forces[i] + forces[i]) * (0.5 * dt);
        }
        
        // Calculate energies and temperature
        double kinetic = calculate_kinetic_energy();
        double temperature = calculate_temperature();
        double total_energy = potential + kinetic;
        
        // Save data
        potential_energy_data.push_back(potential / N);
        kinetic_energy_data.push_back(kinetic / N);
        total_energy_data.push_back(total_energy / N);
        temperature_data.push_back(temperature);
    }
    
    void equilibration(int steps) {
        std::cout << "Starting equilibration for " << steps << " steps..." << std::endl;
        
        for (int step = 0; step < steps; ++step) {
            velocity_verlet_step();
            
            if (step % 100 == 0) {
                std::cout << "Equilibration step " << step << ", T = " 
                          << temperature_data.back() << std::endl;
            }
        }
        
        // Clear any data collected during equilibration
        potential_energy_data.clear();
        kinetic_energy_data.clear();
        total_energy_data.clear();
        temperature_data.clear();
        time_data.clear();
        msd_data.clear();
        
        // Reset initial positions for MSD calculation
        initial_positions = positions;
        
        std::cout << "Equilibration completed." << std::endl;
    }
    
    void run() {
        std::cout << "Starting MD simulation for " << total_steps << " steps..." << std::endl;
        
        // Initial force calculation
        double potential = calculate_forces();
        double kinetic = calculate_kinetic_energy();
        double temperature = calculate_temperature();
        double total_energy = potential + kinetic;
        double msd = 0.0;
        
        // Save initial data
        potential_energy_data.push_back(potential / N);
        kinetic_energy_data.push_back(kinetic / N);
        total_energy_data.push_back(total_energy / N);
        temperature_data.push_back(temperature);
        time_data.push_back(0.0);
        msd_data.push_back(msd);
        
        for (int step = 1; step <= total_steps; ++step) {
            velocity_verlet_step();
            
            double current_time = step * dt;
            time_data.push_back(current_time);
            
            // Calculate MSD
            msd = calculate_msd();
            msd_data.push_back(msd);
            
            if (step % 1000 == 0) {
                std::cout << "Step " << step << "/" << total_steps 
                          << ", T = " << temperature_data.back() 
                          << ", E = " << total_energy_data.back() 
                          << ", MSD = " << msd << std::endl;
            }
        }
        
        std::cout << "Simulation completed." << std::endl;
    }
    
    void save_data(const std::string& prefix) {
        // Save energy data
        std::ofstream energy_file(prefix + "_energy.dat");
        energy_file << "# time potential_energy kinetic_energy total_energy temperature\n";
        
        for (size_t i = 0; i < time_data.size(); ++i) {
            energy_file << time_data[i] << " " 
                      << potential_energy_data[i] << " " 
                      << kinetic_energy_data[i] << " "
                      << total_energy_data[i] << " "
                      << temperature_data[i] << "\n";
        }
        energy_file.close();
        
        // Save MSD data
        std::ofstream msd_file(prefix + "_msd.dat");
        msd_file << "# time msd\n";
        
        for (size_t i = 0; i < time_data.size(); ++i) {
            msd_file << time_data[i] << " " << msd_data[i] << "\n";
        }
        msd_file.close();
        
        // Save final configuration
        std::ofstream config_file(prefix + "_final_config.xyz");
        config_file << N << "\n";
        config_file << "Final configuration\n";
        
        for (int i = 0; i < N; ++i) {
            config_file << "Ar " << positions[i].x << " " << positions[i].y << " 0.0\n";
        }
        config_file.close();
        
        std::cout << "Data saved with prefix: " << prefix << std::endl;
    }
};

int main() {
    // Simulation parameters
    double L = 50.0;                  // Box size
    double rho = 0.7;                 // Number density
    double dt = 0.001;                // Time step
    int total_steps = 100 / dt;       // Total simulation steps (t=100)
    int equilibration_steps = 10000;  // Equilibration steps
    bool use_gaussian = true;         // Use Gaussian velocity distribution
    
    // Create and run simulation
    MDSimulation md(L, rho, dt, total_steps, use_gaussian);
    md.initialize_positions();
    md.initialize_velocities();
    
    // Equilibrate the system
    md.equilibration(equilibration_steps);
    
    // Run the production simulation
    md.run();
    
    // Save data for later analysis
    md.save_data("lj_sim");
    
    return 0;
}
\end{lstlisting}

\subsection*{b. Energy and Temperature Analysis}
The following figures show the potential, kinetic, and total energy per particle, as well as instantaneous temperature $T_i$ as functions of time $t$.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{energy_lj.png}
    \caption{Potential, kinetic, total energy per particle, and instantaneous temperature as functions of time.}
    \label{fig:energy_temp}
\end{figure}

\subsection*{c. Mean-Squared Displacement Analysis}
Figure \ref{fig:msd_lj} shows the mean-squared displacement (MSD) as a function of simulation time $t$, plotted on a logarithmic scale.

\begin{lstlisting}[language=C++, caption=MSD calculation for LJ system]

\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{masd_lj.png}
    \caption{Mean-squared displacement as a function of simulation time, plotted on a logarithmic scale.}
    \label{fig:msd_lj}
\end{figure}

The data was fitted to extract the scaling exponent $\alpha$ in the relation MSD $\sim t^\alpha$.

The calculated value of $\alpha$ is 1.0445 .

\subsection*{Conclusion:}
The molecular dynamics simulation of Lennard-Jones particles in a 2D box ($L=50$, $\rho=0.7$) successfully modeled the behavior of a dense gas system using a truncated and shifted Lennard-Jones potential and the velocity-Verlet integration algorithm with a time step $\Delta t=0.001$. The simulation, run for a total time $t=100$, incorporated a Verlet neighbor list to optimize computational efficiency. The analysis of potential, kinetic, and total energy per particle, along with instantaneous temperature, presented in Figure 8, showed stable energy conservation and temperature fluctuations consistent with the initialized Gaussian velocity distribution. The mean square displacement (MSD), plotted on a logarithmic scale in Figure 9, followed a power-law scaling MSD $\sim t^\alpha$ with $\alpha = 1.0445$, indicating near-normal diffusive behavior, slightly deviating from ideal diffusion ($\alpha = 1.0$) due to particle interactions. This near-linear scaling suggests that the system exhibits diffusive dynamics typical of a dense fluid, with interactions slightly enhancing particle mobility. The simulation's ability to maintain energy conservation and produce physically meaningful MSD scaling underscores the effectiveness of the velocity-Verlet algorithm and neighbor list optimization in modeling complex particle systems.



\end{document}
